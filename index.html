<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#0b0f14" />

<title>Wejuman</title>

<!-- PWA -->
<link rel="manifest" href="./manifest.json" />
<link rel="apple-touch-icon" href="./icons/apple-touch-icon.png" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
:root{
--bg:#0b0f14;
--panel:rgba(255,255,255,.88);
--text:#0b0f14;
--muted:rgba(11,15,20,.65);
--stroke:#0b0f14;
--blue:#2d6cdf;
--green:#28c76f;
}
html,body{height:100%; margin:0; background:var(--bg); font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;}
#map{height:100%; width:100%;}

/* Top info */
.topbar{
position:fixed; left:12px; right:12px; top:12px;
padding:10px 12px;
border-radius:14px;

/* FIX: dark glass for contrast on maps */
background:rgba(11,15,20,.55);
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);

color:#fff;
z-index:1000;
display:flex; gap:10px; align-items:center; justify-content:space-between;

/* prima era pointer-events:none; */
pointer-events:auto;
}

.topbar .title{
font-weight:650; letter-spacing:.2px; font-size:14px;
text-shadow: 0 2px 10px rgba(0,0,0,.55);
}
.topbar .sub{
font-size:12px; opacity:.85;
text-shadow: 0 2px 10px rgba(0,0,0,.55);
}

.toast{
position:fixed; left:50%; transform:translateX(-50%);
bottom:84px; z-index:1200;
background:rgba(0,0,0,.65);
color:#fff;
padding:8px 12px;
border-radius:999px;
font-size:12px;
opacity:0; transition:opacity .18s ease;
pointer-events:none;
max-width:90vw;
text-align:center;
}
.toast.show{opacity:1;}

/* Bottom lens bar */
.lensbar{
position:fixed; left:10px; right:10px; bottom:10px;
display:flex; gap:8px;
padding:10px;
border-radius:18px;
background:var(--panel);
color:var(--text);
z-index:1100;
box-shadow: 0 8px 28px rgba(0,0,0,.25);
overflow-x:auto;
-webkit-overflow-scrolling:touch;
}
.lensbar::-webkit-scrollbar{display:none;}
.lensbtn{
border:1px solid rgba(11,15,20,.12);
background:rgba(255,255,255,.65);
color:var(--text);
padding:10px 12px;
border-radius:14px;
font-size:13px;
font-weight:600;
white-space:nowrap;
cursor:pointer;
user-select:none;
flex:0 0 auto;
}
.lensbtn.active{
background:rgba(11,15,20,.92);
border-color:rgba(11,15,20,.92);
color:#fff;
}
.lensbtn:active{transform:translateY(1px);}

/* Tiny locate button */
.locate{
position:fixed; right:14px; bottom:90px;
z-index:1150;
border:none;
border-radius:999px;
padding:10px 12px;
background:rgba(255,255,255,.9);
color:var(--text);
box-shadow: 0 8px 20px rgba(0,0,0,.2);
font-weight:650;
cursor:pointer;
}

/* Popup */
.popup-title{font-weight:750; margin:0 0 6px 0;}
.popup-meta{font-size:12px; color:rgba(0,0,0,.7); margin:0 0 10px 0;}
.popup-actions{display:flex; gap:8px; flex-wrap:wrap;}
.a-btn{
display:inline-block;
font-size:12px;
padding:7px 10px;
border-radius:10px;
text-decoration:none;
border:1px solid rgba(0,0,0,.15);
color:rgba(0,0,0,.86);
background:rgba(255,255,255,.9);
}
.a-btn.primary{
background:rgba(11,15,20,.92);
border-color:rgba(11,15,20,.92);
color:#fff;
}
</style>
</head>
<body>
<div id="map"></div>

<div class="topbar" aria-hidden="true">
<div class="left">
<div class="title">Wejuman</div>
<div class="sub" id="statusText">Map-first. Silence by default.</div>
</div>
<div class="sub" id="lensText">Lens: Human</div>
</div>

<div class="toast" id="toast"></div>

<button class="locate" id="locateBtn" title="Center on my position">Locate</button>

<div class="lensbar" id="lensBar">
<!-- buttons injected -->
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/***********************
* CONFIG
***********************/
const MIN_ZOOM_FOR_QUERY = 12; // prevents heavy Overpass load
const DEBOUNCE_MS = 450; // wait after user stops moving map
const RESULT_LIMIT = 220; // safety limit per request
const OVERPASS_ENDPOINTS = [
"https://overpass-api.de/api/interpreter",
"https://overpass.kumi.systems/api/interpreter",
"https://overpass.nchc.org.tw/api/interpreter"
];

const LENSES = [
{
id: "human",
label: "Human",
// Public, non-judgment, organizations/actions
query: (bbox) => `
(
node["amenity"="community_centre"](${bbox});
node["amenity"="social_centre"](${bbox});
node["amenity"="food_bank"](${bbox});
node["office"="ngo"](${bbox});
node["office"="charity"](${bbox});
way["amenity"="community_centre"](${bbox});
way["amenity"="social_centre"](${bbox});
way["amenity"="food_bank"](${bbox});
way["office"="ngo"](${bbox});
way["office"="charity"](${bbox});
);
`,
kind: "osm"
},
{
id: "homes_for_sale",
label: "Homes for Sale",
// Not listings; public OSM agents + suggestion link
query: (bbox) => `
(
node["office"="estate_agent"](${bbox});
node["amenity"="estate_agent"](${bbox});
way["office"="estate_agent"](${bbox});
way["amenity"="estate_agent"](${bbox});
);
`,
kind: "osm"
},
{
id: "hotel",
label: "Hotel",
query: (bbox) => `
(
node["tourism"="hotel"](${bbox});
node["tourism"="hostel"](${bbox});
node["tourism"="guest_house"](${bbox});
node["tourism"="apartment"](${bbox});
node["tourism"="camp_site"](${bbox});
way["tourism"="hotel"](${bbox});
way["tourism"="hostel"](${bbox});
way["tourism"="guest_house"](${bbox});
way["tourism"="apartment"](${bbox});
way["tourism"="camp_site"](${bbox});
);
`,
kind: "osm"
},
{
id: "nature",
label: "Nature",
query: (bbox) => `
(
node["leisure"="park"](${bbox});
node["leisure"="nature_reserve"](${bbox});
node["natural"="beach"](${bbox});
node["natural"="peak"](${bbox});
way["leisure"="park"](${bbox});
way["leisure"="nature_reserve"](${bbox});
way["natural"="beach"](${bbox});
);
`,
kind: "osm"
},
{
id: "city",
label: "City / Culture",
query: (bbox) => `
(
node["tourism"="museum"](${bbox});
node["tourism"="attraction"](${bbox});
node["historic"="monument"](${bbox});
node["historic"="memorial"](${bbox});
way["tourism"="museum"](${bbox});
way["tourism"="attraction"](${bbox});
way["historic"="monument"](${bbox});
way["historic"="memorial"](${bbox});
);
`,
kind: "osm"
},
{
id: "mobility",
label: "Mobility",
query: (bbox) => `
(
node["railway"="station"](${bbox});
node["railway"="subway_entrance"](${bbox});
node["amenity"="bus_station"](${bbox});
node["public_transport"="station"](${bbox});
way["railway"="station"](${bbox});
way["amenity"="bus_station"](${bbox});
way["public_transport"="station"](${bbox});
);
`,
kind: "osm"
}
];

/***********************
* MAP INIT
***********************/
const map = L.map("map", { zoomControl: true }).setView([20, 0], 2);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19,
attribution: "&copy; OpenStreetMap contributors"
}).addTo(map);

const statusText = document.getElementById("statusText");
const lensText = document.getElementById("lensText");
const toastEl = document.getElementById("toast");

function toast(msg, ms=1400){
toastEl.textContent = msg;
toastEl.classList.add("show");
window.clearTimeout(toastEl._t);
toastEl._t = window.setTimeout(()=>toastEl.classList.remove("show"), ms);
}

// Layer groups: keep old until new loaded (D3)
let currentLayer = L.layerGroup().addTo(map);
let pendingLayer = null;

/***********************
* VERIFIED STORAGE
***********************/
const VERIFIED_KEY = "wejuman_verified_v01";
const verifiedSet = new Set(JSON.parse(localStorage.getItem(VERIFIED_KEY) || "[]"));

function saveVerified(){
localStorage.setItem(VERIFIED_KEY, JSON.stringify([...verifiedSet]));
}

function makeElementKey(el){
// Works for node/way/relation. Overpass returns type + id.
return `${el.type}/${el.id}`;
}

/***********************
* MARKER STYLE
***********************/
function markerStyle(isVerified){
return {
radius: 7,
weight: 2,
color: getComputedStyle(document.documentElement).getPropertyValue("--stroke").trim() || "#0b0f14",
fillColor: isVerified
? (getComputedStyle(document.documentElement).getPropertyValue("--green").trim() || "#28c76f")
: (getComputedStyle(document.documentElement).getPropertyValue("--blue").trim() || "#2d6cdf"),
fillOpacity: 0.9
};
}

function elementCenter(el){
if (el.type === "node") return [el.lat, el.lon];
// ways have "center" when using out center
if (el.center) return [el.center.lat, el.center.lon];
return null;
}

function pickName(tags){
return tags.name || tags["name:en"] || tags.brand || tags.operator || "Unnamed";
}

function pickCategory(lensId, tags){
// Keep it minimal
if (lensId === "homes_for_sale") return "Estate agent";
if (lensId === "hotel") return tags.tourism || "Stay";
if (lensId === "nature") return tags.leisure || tags.natural || "Nature";
if (lensId === "city") return tags.tourism || tags.historic || "Place";
if (lensId === "mobility") return tags.railway || tags.amenity || tags.public_transport || "Mobility";
return tags.office || tags.amenity || "Human action";
}

function buildWebsite(tags){
return tags.website || tags["contact:website"] || tags.url || null;
}

function osmLink(el){
return `https://www.openstreetmap.org/${el.type}/${el.id}`;
}

function buildHomesForSaleSearchLink(){
// Universal suggestion: Google query anchored to map center
const c = map.getCenter();
const q = encodeURIComponent(`homes for sale near ${c.lat.toFixed(5)},${c.lng.toFixed(5)}`);
return `https://www.google.com/search?q=${q}`;
}

/***********************
* POPUP + VERIFY (Mode 1: only inside popup)
***********************/
function popupHtml({lensId, el, tags, isVerified}){
const name = pickName(tags);
const cat = pickCategory(lensId, tags);
const site = buildWebsite(tags);
const osm = osmLink(el);

const actions = [];

// Keep external links as you asked
if (site) actions.push(`<a class="a-btn" href="${site}" target="_blank" rel="noopener">Website</a>`);
actions.push(`<a class="a-btn" href="${osm}" target="_blank" rel="noopener">OSM</a>`);

// Homes for Sale: suggestion market link
if (lensId === "homes_for_sale") {
actions.push(`<a class="a-btn" href="${buildHomesForSaleSearchLink()}" target="_blank" rel="noopener">Search homes for sale near here</a>`);
}

// Verify action (invisible until marker tapped)
actions.push(`<a class="a-btn primary" href="#" data-verify="1">${isVerified ? "Verified" : "I was here"}</a>`);

return `
<div>
<div class="popup-title">${escapeHtml(name)}</div>
<div class="popup-meta">${escapeHtml(cat)} · Public data</div>
<div class="popup-actions">${actions.join("")}</div>
</div>
`;
}

function escapeHtml(str){
return String(str).replace(/[&<>"']/g, s => ({
"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
}[s]));
}

/***********************
* OVERPASS FETCH with retry + fallback
***********************/
async function fetchOverpass(query, timeoutMs=12000){
let lastErr = null;

for (let attempt = 0; attempt < 3; attempt++){
for (const endpoint of OVERPASS_ENDPOINTS){
try{
const controller = new AbortController();
const t = setTimeout(()=>controller.abort(), timeoutMs);

const res = await fetch(endpoint, {
method: "POST",
body: query,
signal: controller.signal,
headers: { "Content-Type": "text/plain;charset=UTF-8" }
});

clearTimeout(t);

if (!res.ok) {
lastErr = new Error(`Overpass HTTP ${res.status}`);
continue;
}
return await res.json();
} catch (e){
lastErr = e;
// try next endpoint
}
}
// brief backoff
await new Promise(r=>setTimeout(r, 650 + attempt*450));
}

throw lastErr || new Error("Overpass error");
}

function bboxString(){
const b = map.getBounds();
return `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
}

function makeOverpassBody(lens){
const bbox = bboxString();
const inner = lens.query(bbox);

// out center makes ways return center point
return `
[out:json][timeout:25];
${inner}
out center ${RESULT_LIMIT};
`;
}

/***********************
* RENDER
***********************/
function renderElements(lensId, elements){
const layer = L.layerGroup();

for (const el of elements){
const center = elementCenter(el);
if (!center) continue;

const tags = el.tags || {};
const key = makeElementKey(el);
const isVerified = verifiedSet.has(key);

const m = L.circleMarker(center, markerStyle(isVerified));
m._wejuman = { key, lensId, el, tags };

m.on("popupopen", (ev) => {
const popupEl = ev.popup.getElement();
if (!popupEl) return;

popupEl.addEventListener("click", (e) => {
const a = e.target.closest("a[data-verify]");
if (!a) return;
e.preventDefault();

// toggle verify -> green (we keep it as "verify once"; toggling allowed but optional)
if (!verifiedSet.has(key)) {
verifiedSet.add(key);
saveVerified();
// update marker style immediately
m.setStyle(markerStyle(true));
toast("Confirmed.");
// update popup label
a.textContent = "Verified";
} else {
// If you prefer "no unverify", comment this block out
verifiedSet.delete(key);
saveVerified();
m.setStyle(markerStyle(false));
toast("Unconfirmed.");
a.textContent = "I was here";
}
}, { once: true }); // keeps it clean; reopened popup rebinds
});

m.bindPopup(popupHtml({lensId, el, tags, isVerified}), { maxWidth: 320 });
layer.addLayer(m);
}
return layer;
}

/***********************
* LENS UI
***********************/
const lensBar = document.getElementById("lensBar");
let activeLens = LENSES[0];

function setActiveLens(lens){
activeLens = lens;
lensText.textContent = `Lens: ${lens.label}`;

// UI
[...lensBar.querySelectorAll(".lensbtn")].forEach(btn=>{
btn.classList.toggle("active", btn.dataset.lensId === lens.id);
});

// refresh query
scheduleRefresh(true);
}

function buildLensButtons(){
for (const lens of LENSES){
const btn = document.createElement("button");
btn.className = "lensbtn" + (lens.id === activeLens.id ? " active" : "");
btn.textContent = lens.label;
btn.dataset.lensId = lens.id;
btn.onclick = () => setActiveLens(lens);
lensBar.appendChild(btn);
}
}
buildLensButtons();

/***********************
* REFRESH LOGIC (debounce + min zoom + D3 old markers stay)
***********************/
let debounceTimer = null;
let inFlight = 0;

function scheduleRefresh(force=false){
if (debounceTimer) clearTimeout(debounceTimer);
debounceTimer = setTimeout(()=>refresh(force), force ? 0 : DEBOUNCE_MS);
}

async function refresh(force=false){
const z = map.getZoom();

if (z < MIN_ZOOM_FOR_QUERY) {
statusText.textContent = `Zoom in to load data (min zoom ${MIN_ZOOM_FOR_QUERY}).`;
return;
}

const myFlight = ++inFlight;
statusText.textContent = "Loading…";
toast("Loading…", 900);

const q = makeOverpassBody(activeLens);

try{
const data = await fetchOverpass(q);
if (myFlight !== inFlight) return; // stale result

const elements = (data && data.elements) ? data.elements : [];
const nextLayer = renderElements(activeLens.id, elements);

// D3: keep old markers until new ready, then swap
pendingLayer = nextLayer;
map.addLayer(pendingLayer);
map.removeLayer(currentLayer);
currentLayer = pendingLayer;
pendingLayer = null;

statusText.textContent = `${elements.length} places · Public data`;
} catch (e){
if (myFlight !== inFlight) return;
statusText.textContent = "Data source busy. Retrying on movement…";
toast("Data source busy. Try again.", 1400);
}
}

map.on("moveend zoomend", ()=>scheduleRefresh(false));

/***********************
* GEOLOCATION (ask once on entry) + locate button
***********************/
let askedGeo = false;

async function requestGeoOnce(){
if (askedGeo) return;
askedGeo = true;

if (!("geolocation" in navigator)) {
toast("Geolocation not available.");
return;
}

navigator.geolocation.getCurrentPosition(
(pos) => {
const lat = pos.coords.latitude;
const lon = pos.coords.longitude;
map.setView([lat, lon], 13, { animate: true });
toast("Centered on you.");
scheduleRefresh(true);
},
(err) => {
// No insistence; respect silence
toast("Location not granted.");
},
{ enableHighAccuracy: false, timeout: 8000, maximumAge: 600000 }
);
}

// Entry: ask once (your requirement)
requestGeoOnce();

// Manual locate
document.getElementById("locateBtn").addEventListener("click", ()=>{
askedGeo = false; // allow manual re-ask when user chooses
requestGeoOnce();
});

/***********************
* PWA: register service worker
***********************/
if ("serviceWorker" in navigator) {
window.addEventListener("load", async () => {
try {
await navigator.serviceWorker.register("./sw.js");
} catch (e) { /* silent */ }
});
}

// First load
scheduleRefresh(true);
</script>
</body>
</html>
