<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Wejuman — A living map of human action</title>

<!-- Leaflet -->
<link
rel="stylesheet"
href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""
/>
<script
src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""
></script>

<style>
:root{
--bg: #f3f4f6;
--card: rgba(255,255,255,0.92);
--card2: rgba(255,255,255,0.96);
--text: #111827;
--muted: #6b7280;
--line: rgba(17,24,39,0.10);
--shadow: 0 10px 30px rgba(0,0,0,0.12);
--radius: 18px;
--radius2: 22px;
}
html, body { height: 100%; margin: 0; background: var(--bg); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, sans-serif; color: var(--text); }
#app { height: 100%; position: relative; overflow: hidden; }
#map { height: 100%; width: 100%; }

/* Top bar */
.topbar {
position: absolute;
top: env(safe-area-inset-top, 0px);
left: 0;
right: 0;
padding: 12px 12px 0 12px;
z-index: 500;
pointer-events: none;
}
.topbar-inner {
pointer-events: auto;
display: flex;
gap: 10px;
align-items: center;
justify-content: space-between;
background: var(--card);
backdrop-filter: blur(14px);
-webkit-backdrop-filter: blur(14px);
border: 1px solid var(--line);
border-radius: var(--radius2);
box-shadow: var(--shadow);
padding: 10px 12px;
}
.leftgrp { display: flex; align-items: center; gap: 10px; min-width: 0; }
.hamb {
width: 44px; height: 44px; border-radius: 14px;
display: grid; place-items: center;
border: 1px solid var(--line);
background: rgba(255,255,255,0.75);
cursor: pointer;
flex: 0 0 auto;
}
.hamb svg { width: 22px; height: 22px; }
.titlegrp { min-width: 0; }
.brand { font-weight: 800; font-size: 20px; line-height: 1.1; }
.sub { font-size: 13px; color: var(--muted); line-height: 1.2; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.locline { font-weight: 700; margin-top: 2px; }
.chip {
flex: 0 0 auto;
border: 1px solid var(--line);
background: rgba(255,255,255,0.82);
padding: 10px 12px;
border-radius: 999px;
font-size: 14px;
color: var(--text);
display: inline-flex;
gap: 8px;
align-items: center;
white-space: nowrap;
}

/* Bottom sheet */
.sheet {
position: absolute;
left: 0;
right: 0;
bottom: env(safe-area-inset-bottom, 0px);
z-index: 500;
padding: 0 12px 12px 12px;
pointer-events: none;
}
.sheet-inner {
pointer-events: auto;
background: var(--card2);
border: 1px solid var(--line);
border-radius: var(--radius2);
box-shadow: var(--shadow);
overflow: hidden;
max-height: min(52vh, 520px);
display: flex;
flex-direction: column;
}
.sheet-head {
padding: 14px 16px 10px 16px;
border-bottom: 1px solid var(--line);
display: flex;
align-items: baseline;
justify-content: space-between;
gap: 12px;
}
.sheet-title { font-weight: 900; font-size: 26px; }
.sheet-meta { font-size: 13px; color: var(--muted); white-space: nowrap; }
.list {
overflow: auto;
-webkit-overflow-scrolling: touch;
}
.row {
padding: 14px 16px;
border-bottom: 1px solid var(--line);
cursor: pointer;
}
.row:last-child { border-bottom: 0; }
.row h4 { margin: 0; font-size: 18px; letter-spacing: 0.2px; }
.row p { margin: 6px 0 0; color: var(--muted); font-size: 14px; }
.pill {
display: inline-flex;
gap: 6px;
align-items: center;
border: 1px solid var(--line);
background: rgba(255,255,255,0.7);
border-radius: 999px;
padding: 4px 10px;
font-size: 12px;
margin-left: 8px;
color: var(--text);
}

/* Sidebar */
.side {
position: absolute;
top: 0; bottom: 0; left: 0;
width: min(320px, 85vw);
z-index: 600;
transform: translateX(-110%);
transition: transform .22s ease;
background: rgba(255,255,255,0.96);
border-right: 1px solid var(--line);
box-shadow: 10px 0 30px rgba(0,0,0,0.10);
padding: calc(env(safe-area-inset-top, 0px) + 14px) 14px 14px 14px;
}
.side.open { transform: translateX(0); }
.overlay {
position: absolute; inset: 0;
background: rgba(0,0,0,0.25);
z-index: 590;
opacity: 0;
pointer-events: none;
transition: opacity .22s ease;
}
.overlay.show { opacity: 1; pointer-events: auto; }
.side h3 { margin: 0 0 12px; font-size: 18px; }
.btn {
width: 100%;
padding: 12px 12px;
border-radius: 14px;
border: 1px solid var(--line);
background: white;
text-align: left;
font-size: 14px;
margin-bottom: 8px;
}
.hint { color: var(--muted); font-size: 13px; line-height: 1.35; margin-top: 10px; }

/* Leaflet tweaks */
.leaflet-control-container { display:none; } /* pulito stile app-like */
</style>
</head>

<body>
<div id="app">
<div id="map"></div>

<div class="topbar">
<div class="topbar-inner">
<div class="leftgrp">
<button class="hamb" id="hambBtn" aria-label="Menu">
<svg viewBox="0 0 24 24" fill="none">
<path d="M4 7h16M4 12h16M4 17h16" stroke="#111827" stroke-width="2" stroke-linecap="round"/>
</svg>
</button>
<div class="titlegrp">
<div class="brand">Wejuman</div>
<div class="sub">A living map of human action</div>
<div class="locline" id="locationLabel">—</div>
</div>
</div>
<div class="chip" title="Fonte dati">
<span style="opacity:.8">Dati:</span>
<strong>points.json</strong>
</div>
</div>
</div>

<div class="sheet">
<div class="sheet-inner">
<div class="sheet-head">
<div class="sheet-title">Nearby</div>
<div class="sheet-meta" id="nearbyMeta">Tocca la mappa per aggiornare</div>
</div>
<div class="list" id="nearbyList"></div>
</div>
</div>

<div class="overlay" id="overlay"></div>
<aside class="side" id="side">
<h3>Menu</h3>
<button class="btn" id="btnMyPos">Vai alla mia posizione</button>
<button class="btn" id="btnWorld">Vista mondo</button>
<button class="btn" id="btnResetNearby">Reset “Nearby”</button>
<div class="hint">
Logica attuale: la lista “Nearby” mostra sempre le <b>20 iniziative più vicine</b> al punto che tocchi sulla mappa (anche se non c’è un marker).
</div>
</aside>
</div>

<script>
// =========================
// CONFIG
// =========================
const POINTS_URL = "points.json";
const NEARBY_LIMIT = 20;

// NOTE: NON tocchiamo il JSON.
// Accettiamo più schemi possibili:
// - lat/lng (o latitude/longitude)
// - name/title
// - type/category + scope
// - url/website
// Qualunque campo manchi: fallback safe.

// =========================
// STATE
// =========================
let ALL_POINTS = [];
let markersLayer = null;
let lastQueryLatLng = null;

// =========================
// MAP
// =========================
const map = L.map("map", { zoomControl: false, attributionControl: false })
.setView([45.4642, 9.1900], 11);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19
}).addTo(map);

markersLayer = L.layerGroup().addTo(map);

// =========================
// UI HELPERS
// =========================
const $ = (id) => document.getElementById(id);
const nearbyListEl = $("nearbyList");
const nearbyMetaEl = $("nearbyMeta");
const locationLabelEl = $("locationLabel");

function setLocationLabelFromLatLng(latlng) {
// Manteniamo semplice (come app): nome città “smart” non serve ora.
// Mostriamo un’etichetta tipo: "Milano" se siamo vicino al default, altrimenti coordinate.
const isMilan = Math.abs(latlng.lat - 45.4642) < 0.25 && Math.abs(latlng.lng - 9.19) < 0.35;
locationLabelEl.textContent = isMilan ? "Milano" : `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
}

function escapeHtml(str) {
return String(str ?? "")
.replaceAll("&","&amp;")
.replaceAll("<","&lt;")
.replaceAll(">","&gt;")
.replaceAll('"',"&quot;")
.replaceAll("'","&#039;");
}

// =========================
// DISTANCE (Haversine)
// =========================
function haversineKm(lat1, lon1, lat2, lon2) {
const R = 6371;
const dLat = (lat2 - lat1) * Math.PI / 180;
const dLon = (lon2 - lon1) * Math.PI / 180;
const a =
Math.sin(dLat/2) * Math.sin(dLat/2) +
Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
Math.sin(dLon/2) * Math.sin(dLon/2);
return 2 * R * Math.asin(Math.sqrt(a));
}

// =========================
// NORMALIZE POINTS (NO JSON CHANGE)
// =========================
function normalizePoint(raw) {
const lat = Number(raw.lat ?? raw.latitude);
const lng = Number(raw.lng ?? raw.lon ?? raw.longitude);
if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;

const name = raw.name ?? raw.title ?? raw.org ?? raw.organization ?? "Untitled";
const type = raw.type ?? raw.category ?? raw.kind ?? "Community center";
const scope = raw.scope ?? raw.levelScope ?? raw.scale ?? "Local";
const url = raw.url ?? raw.website ?? raw.link ?? "";

return {
...raw,
lat, lng,
_name: String(name),
_type: String(type),
_scope: String(scope),
_url: String(url)
};
}

// =========================
// RENDER LIST
// =========================
function renderNearbyList(list) {
nearbyListEl.innerHTML = "";

if (!list || list.length === 0) {
nearbyListEl.innerHTML = `<div class="row"><h4>Nessun risultato</h4><p>Carica points.json o tocca la mappa.</p></div>`;
return;
}

const frag = document.createDocumentFragment();

list.forEach(p => {
const row = document.createElement("div");
row.className = "row";

const d = Number.isFinite(p._distKm) ? p._distKm : null;
const distStr = d == null ? "" : `${d.toFixed(1)} km`;
const typeStr = escapeHtml(p._type || "Community center");
const scopeStr = escapeHtml(p._scope || "Local");
const nameStr = escapeHtml(p._name || "Untitled");

row.innerHTML = `
<h4>${nameStr}</h4>
<p>${typeStr} · ${distStr} · ${scopeStr}</p>
`;

row.addEventListener("click", () => {
// centriamo sulla iniziativa selezionata
map.flyTo([p.lat, p.lng], Math.max(map.getZoom(), 13), { duration: 0.55 });

// se ha un link, apri in nuova scheda (facoltativo)
if (p._url && /^https?:\/\//i.test(p._url)) {
window.open(p._url, "_blank", "noopener,noreferrer");
}
});

frag.appendChild(row);
});

nearbyListEl.appendChild(frag);
}

// =========================
// CORE BEHAVIOR: 20 nearest to tap (no radius / no 300km)
// =========================
function updateNearbyFromCenter(centerLatLng) {
if (!centerLatLng || !Array.isArray(ALL_POINTS) || ALL_POINTS.length === 0) return;

const cLat = centerLatLng.lat;
const cLng = centerLatLng.lng;

const ranked = ALL_POINTS
.map(p => {
const dKm = haversineKm(cLat, cLng, p.lat, p.lng);
return { ...p, _distKm: dKm };
})
.sort((a, b) => a._distKm - b._distKm)
.slice(0, NEARBY_LIMIT);

lastQueryLatLng = centerLatLng;
setLocationLabelFromLatLng(centerLatLng);
nearbyMetaEl.textContent = `20 più vicine al punto selezionato`;
renderNearbyList(ranked);
}

// =========================
// MARKERS
// =========================
function addMarkers(points) {
markersLayer.clearLayers();

points.forEach(p => {
const m = L.marker([p.lat, p.lng], { keyboard: false });

// IMPORTANT: nessun popup
m.on("click", (e) => {
updateNearbyFromCenter(e.latlng);
});

m.addTo(markersLayer);
});
}

// =========================
// MAP EVENTS
// =========================
map.on("click", (e) => {
// Anche se tocchi in un punto senza marker: aggiorna Nearby
updateNearbyFromCenter(e.latlng);
});

// =========================
// MENU (sidebar)
// =========================
const side = $("side");
const overlay = $("overlay");
const hambBtn = $("hambBtn");

function openSide() { side.classList.add("open"); overlay.classList.add("show"); }
function closeSide() { side.classList.remove("open"); overlay.classList.remove("show"); }

hambBtn.addEventListener("click", () => {
if (side.classList.contains("open")) closeSide(); else openSide();
});
overlay.addEventListener("click", closeSide);

$("btnWorld").addEventListener("click", () => {
closeSide();
map.flyTo([20, 0], 2, { duration: 0.7 });
});

$("btnResetNearby").addEventListener("click", () => {
closeSide();
lastQueryLatLng = null;
nearbyMetaEl.textContent = "Tocca la mappa per aggiornare";
renderNearbyList([]);
locationLabelEl.textContent = "—";
});

$("btnMyPos").addEventListener("click", () => {
closeSide();
if (!navigator.geolocation) return alert("Geolocalizzazione non disponibile.");
navigator.geolocation.getCurrentPosition(
(pos) => {
const latlng = { lat: pos.coords.latitude, lng: pos.coords.longitude };
map.flyTo([latlng.lat, latlng.lng], 12, { duration: 0.7 });
// Se vuoi: far partire subito le 20 più vicine alla tua posizione
updateNearbyFromCenter(latlng);
},
() => alert("Impossibile ottenere la posizione."),
{ enableHighAccuracy: true, timeout: 8000, maximumAge: 60000 }
);
});

// =========================
// LOAD DATA (points.json) - NO JSON CHANGE
// =========================
async function loadPoints() {
const res = await fetch(POINTS_URL, { cache: "no-store" });
if (!res.ok) throw new Error("Impossibile caricare points.json");
const data = await res.json();

const arr = Array.isArray(data) ? data : (data.points ?? data.features ?? []);
const norm = [];

for (const raw of arr) {
// support GeoJSON Feature
const candidate = raw?.type === "Feature" && raw.geometry?.type === "Point"
? {
...(raw.properties || {}),
lat: raw.geometry.coordinates?.[1],
lng: raw.geometry.coordinates?.[0]
}
: raw;

const p = normalizePoint(candidate);
if (p) norm.push(p);
}

ALL_POINTS = norm;
addMarkers(ALL_POINTS);

// Primo stato: centro attuale mappa
const c = map.getCenter();
setLocationLabelFromLatLng(c);
// Mostra già qualcosa senza obbligare il tap (opzionale):
updateNearbyFromCenter(c);
}

// Boot
renderNearbyList([]);
loadPoints().catch(err => {
console.error(err);
nearbyMetaEl.textContent = "Errore: points.json non caricato";
nearbyListEl.innerHTML = `<div class="row"><h4>Errore</h4><p>Non riesco a leggere <b>points.json</b>. Controlla che sia nella stessa cartella di index.html.</p></div>`;
});
</script>
</body>
</html>
