<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wejuman</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- MarkerCluster -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<script defer src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- Geocoder -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
<script defer src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

<style>
:root{
--bg: #0b0c10;
--panel: rgba(255,255,255,0.10);
--text: rgba(255,255,255,0.92);
--muted: rgba(255,255,255,0.70);
--stroke: rgba(255,255,255,0.14);
--shadow: 0 10px 30px rgba(0,0,0,0.35);
--radius: 14px;
}
html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
#map { height:100%; width:100%; }

/* Topbar */
.topbar{
position: fixed;
top: 14px;
left: 14px;
right: 14px;
z-index: 9999;
display:flex;
align-items:center;
justify-content:space-between;
padding: 10px 12px;
border-radius: var(--radius);
background: linear-gradient(180deg, rgba(255,255,255,0.13), rgba(255,255,255,0.08));
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(10px);
transform: translateY(0);
transition: transform .22s ease, opacity .22s ease;
}
.topbar.is-dim{ opacity: 0.72; }
.topbar.is-lower{ transform: translateY(54px); }
.topbar__left{ display:flex; align-items:center; gap:10px; }
.topbar__right{ display:flex; align-items:center; gap:8px; }
.brand__title{ font-weight: 650; letter-spacing: .2px; }
.brand__subtitle{ font-size: 12px; color: var(--muted); margin-top: 1px; }

.iconbtn{
border: 1px solid var(--stroke);
background: rgba(0,0,0,0.22);
color: var(--text);
border-radius: 12px;
width: 40px; height: 40px;
display:grid; place-items:center;
cursor: pointer;
}
.pill{
border: 1px solid var(--stroke);
background: rgba(0,0,0,0.22);
color: var(--text);
border-radius: 999px;
padding: 10px 12px;
cursor:pointer;
font-size: 13px;
}

/* Drawer */
.drawer{
position: fixed;
top: 14px;
left: 14px;
width: min(360px, calc(100vw - 28px));
max-height: calc(100vh - 28px);
z-index: 10000;
background: rgba(10,12,16,0.74);
border: 1px solid var(--stroke);
border-radius: var(--radius);
backdrop-filter: blur(14px);
box-shadow: var(--shadow);
transform: translateX(-110%);
transition: transform .22s ease;
overflow:hidden;
}
.drawer.is-open{ transform: translateX(0); }
.drawer__header{
display:flex;
align-items:center;
justify-content:space-between;
padding: 12px 12px 8px 12px;
border-bottom: 1px solid rgba(255,255,255,0.10);
}
.drawer__title{ font-weight: 650; }
.drawer__body{ padding: 12px; overflow:auto; max-height: calc(100vh - 90px); }
.drawer__note{ margin: 0 0 12px 0; font-size: 13px; color: var(--muted); }
.divider{ height: 1px; background: rgba(255,255,255,0.10); margin: 12px 0; }

.chips{ display:flex; flex-wrap: wrap; gap: 8px; }
.chip{
border: 1px solid rgba(255,255,255,0.16);
background: rgba(255,255,255,0.06);
color: var(--text);
border-radius: 999px;
padding: 9px 10px;
font-size: 13px;
cursor:pointer;
user-select:none;
transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
.chip:hover{ transform: translateY(-1px); }
.chip.is-on{ background: rgba(255,255,255,0.16); border-color: rgba(255,255,255,0.26); }

.switchrow{ display:flex; align-items:center; gap:10px; font-size: 13px; color: var(--muted); }
.small{ font-size: 13px; color: var(--muted); }
.muted{ color: var(--muted); }

/* Leaflet controls harmonization */
.leaflet-control-geocoder{
border-radius: 12px !important;
overflow:hidden;
border: 1px solid rgba(255,255,255,0.14) !important;
backdrop-filter: blur(10px);
}
.leaflet-control-geocoder-icon{ background-color: rgba(0,0,0,0.20) !important; }
.leaflet-control-geocoder-form input{
background: rgba(0,0,0,0.18) !important;
color: rgba(255,255,255,0.92) !important;
}
.leaflet-control-geocoder-form input::placeholder{ color: rgba(255,255,255,0.55); }

/* ‚Äúbreath‚Äù */
.breath{
position: fixed;
inset: 0;
z-index: 2;
pointer-events:none;
background: radial-gradient(1200px 900px at 30% 20%, rgba(255,255,255,0.05), transparent 60%),
radial-gradient(1100px 800px at 80% 75%, rgba(255,255,255,0.04), transparent 55%);
opacity: .65;
animation: breathe 8s ease-in-out infinite;
}
@keyframes breathe{
0%{ transform: scale(1); opacity:.55; }
50%{ transform: scale(1.02); opacity:.72; }
100%{ transform: scale(1); opacity:.55; }
}

/* Suggestions bar (non invasiva, no CTA) */
.suggest{
position: fixed;
left: 14px;
right: 14px;
bottom: 14px;
z-index: 9999;
border-radius: var(--radius);
background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(12px);
padding: 10px 12px;
display:flex;
gap: 10px;
align-items:flex-start;
transition: transform .18s ease, opacity .18s ease;
}
.suggest.is-hidden{ opacity: 0; transform: translateY(10px); pointer-events:none; }
.suggest__title{ font-size: 12px; color: var(--muted); margin-bottom: 6px; }
.suggest__items{ display:flex; flex-direction:column; gap:6px; }
.sitem{ font-size: 13px; color: var(--text); }
.sitem .meta{ color: var(--muted); font-size: 12px; }

/* Popup minimal styling */
.popup .pname{ font-weight: 650; margin-bottom: 2px; }
.popup .pmuted{ color: rgba(255,255,255,0.72); font-size: 12px; margin-bottom: 8px; }
.popup .ptext{ font-size: 13px; color: rgba(255,255,255,0.88); margin-bottom: 8px; }
.popup .pmeta{ font-size: 12px; color: rgba(255,255,255,0.72); }
.popup a{ color: rgba(255,255,255,0.92); text-decoration: underline; }
</style>
</head>

<body>
<div id="map"></div>

<div class="topbar" id="topbar">
<div class="topbar__left">
<button class="iconbtn" id="btnMenu" aria-label="Apri menu">‚ò∞</button>
<div class="brand">
<div class="brand__title">Wejuman</div>
<div class="brand__subtitle" id="modeHint">Coscienza globale</div>
</div>
</div>
<div class="topbar__right">
<button class="pill" id="btnLocate" title="La mia posizione">üìç</button>
<button class="pill" id="btnReset" title="Reset filtri">Reset</button>
</div>
</div>

<aside class="drawer" id="drawer" aria-hidden="true">
<div class="drawer__header">
<div class="drawer__title">Categorie</div>
<button class="iconbtn" id="btnClose" aria-label="Chiudi">‚úï</button>
</div>
<div class="drawer__body">
<p class="drawer__note">
Il filtro <b>non giudica</b>: evidenzia ci√≤ che cerchi, senza ‚Äúcancellare‚Äù il resto.
</p>

<div class="chips" id="chips"></div>

<div class="divider"></div>

<label class="switchrow">
<input type="checkbox" id="onlyHighlighted" />
<span>Mostra solo evidenziati</span>
</label>

<div class="divider"></div>

<div class="small">
<div><b>Punti caricati:</b> <span id="countAll">‚Äî</span></div>
<div><b>Evidenziati:</b> <span id="countHi">‚Äî</span></div>
<div><b>Celle caricate:</b> <span id="countCells">‚Äî</span></div>
<div class="muted" style="margin-top:8px">
Zoom = informazioni progressive (Lontano ‚Üí Medio ‚Üí Vicino).
</div>
</div>
</div>
</aside>

<!-- Suggestions bar -->
<div class="suggest is-hidden" id="suggest">
<div style="min-width: 140px;">
<div class="suggest__title" id="suggestTitle">Vicino a te</div>
<div class="muted" style="font-size:12px" id="suggestSubtitle">3 azioni di cura (tra i punti caricati)</div>
</div>
<div class="suggest__items" id="suggestItems"></div>
</div>

<div class="breath" aria-hidden="true"></div>

<script>
/******************************************************************
* CONFIG ‚Äì BBOX Progressive loading (static-friendly)
*
* Strategie:
* - Pre-splitti i punti in celle GRID_DEG x GRID_DEG
* - Ogni cella √® un GeoJSON in: /data/cells/c_{latIdx}_{lonIdx}.geojson
* - latIdx = floor((lat + 90) / GRID_DEG)
* - lonIdx = floor((lon + 180) / GRID_DEG)
*
* Esempio: GRID_DEG=5 => latIdx 0..35, lonIdx 0..71
******************************************************************/
const GRID_DEG = 5;
const CELLS_PATH = "./data/cells"; // cartella dove metti i file cella
const MAX_POINTS_FOR_SUGGESTIONS_SCAN = 60000; // sicurezza (non serve, ma evita stress)

// Zoom modes
const ZOOM_FAR_MAX = 3;
const ZOOM_MID_MAX = 6;

// State
const state = {
categories: new Map(), // cat -> boolean
onlyHighlighted: false,
loadedCells: new Set(), // "latIdx|lonIdx"
features: [], // all loaded features
markersById: new Map(), // featureId -> leaflet layer
highlightedCount: 0,
userLatLng: null, // last known user position
};

// UI refs
const topbar = document.getElementById("topbar");
const drawer = document.getElementById("drawer");
const chipsEl = document.getElementById("chips");
const modeHint = document.getElementById("modeHint");
const countAll = document.getElementById("countAll");
const countHi = document.getElementById("countHi");
const countCells = document.getElementById("countCells");
const onlyHighlightedEl = document.getElementById("onlyHighlighted");

const suggestEl = document.getElementById("suggest");
const suggestTitle = document.getElementById("suggestTitle");
const suggestSubtitle = document.getElementById("suggestSubtitle");
const suggestItems = document.getElementById("suggestItems");

// Map
const map = L.map("map", { zoomControl:true, preferCanvas:true, worldCopyJump:true });
map.setView([20, 0], 2);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19,
attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const cluster = L.markerClusterGroup({
chunkedLoading: true,
chunkDelay: 20,
maxClusterRadius: 60,
showCoverageOnHover: false,
});
map.addLayer(cluster);

// Geocoder
const geocoder = L.Control.Geocoder.nominatim();
const geocoderControl = L.Control.geocoder({
geocoder,
defaultMarkGeocode: false,
placeholder: "Cerca un luogo‚Ä¶",
}).addTo(map);
geocoderControl.on("markgeocode", (e) => {
const bbox = e.geocode.bbox;
const bounds = L.latLngBounds(bbox.getSouthEast(), bbox.getNorthWest());
map.fitBounds(bounds, { padding: [40, 40] });
});

// Topbar ‚Äúlower while interacting‚Äù
let interactionTimer = null;
function setTopbarLowered(on){
topbar.classList.toggle("is-lower", on);
topbar.classList.toggle("is-dim", on);
}
function pulseInteraction(){
setTopbarLowered(true);
clearTimeout(interactionTimer);
interactionTimer = setTimeout(() => setTopbarLowered(false), 600);
}
map.on("movestart zoomstart dragstart", pulseInteraction);

// Drawer
document.getElementById("btnMenu").addEventListener("click", () => openDrawer(true));
document.getElementById("btnClose").addEventListener("click", () => openDrawer(false));
function openDrawer(open){
drawer.classList.toggle("is-open", open);
drawer.setAttribute("aria-hidden", open ? "false" : "true");
}
map.on("click", () => openDrawer(false));

// Locate
document.getElementById("btnLocate").addEventListener("click", () => {
if (!navigator.geolocation) return alert("Geolocalizzazione non disponibile.");
navigator.geolocation.getCurrentPosition(
(pos) => {
const { latitude, longitude } = pos.coords;
state.userLatLng = L.latLng(latitude, longitude);
map.flyTo([latitude, longitude], Math.max(map.getZoom(), 10), { duration: 0.8 });
updateSuggestions();
},
() => alert("Permesso posizione negato o errore.")
);
});

// Reset
document.getElementById("btnReset").addEventListener("click", () => {
for (const k of state.categories.keys()) state.categories.set(k, false);
state.onlyHighlighted = false;
onlyHighlightedEl.checked = false;
rebuildChips();
applyFilterAndRender();
updateSuggestions();
});

onlyHighlightedEl.addEventListener("change", (e) => {
state.onlyHighlighted = !!e.target.checked;
applyFilterAndRender();
updateSuggestions();
});

// Zoom modes
function getZoomMode(z){
if (z <= ZOOM_FAR_MAX) return "far";
if (z <= ZOOM_MID_MAX) return "mid";
return "near";
}
function setModeHint(){
const mode = getZoomMode(map.getZoom());
if (mode === "far") modeHint.textContent = "Coscienza globale";
else if (mode === "mid") modeHint.textContent = "Scoperta";
else modeHint.textContent = "Presenza umana";
}

// Progressive load on move/zoom end (bbox)
let bboxDebounce = null;
map.on("moveend zoomend", () => {
setModeHint();
clearTimeout(bboxDebounce);
bboxDebounce = setTimeout(async () => {
await loadVisibleCells();
applyFilterAndRender();
updateSuggestions();
}, 120);
});

// ---- BBOX ‚Üí cell keys
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function latLonToIdx(lat, lon){
const latIdx = Math.floor((lat + 90) / GRID_DEG);
const lonIdx = Math.floor((lon + 180) / GRID_DEG);
return { latIdx, lonIdx };
}

function cellKey(latIdx, lonIdx){
return `${latIdx}|${lonIdx}`;
}

function cellUrl(latIdx, lonIdx){
return `${CELLS_PATH}/c_${latIdx}_${lonIdx}.geojson`;
}

function bboxToCellRange(bounds){
const south = clamp(bounds.getSouth(), -89.9999, 89.9999);
const north = clamp(bounds.getNorth(), -89.9999, 89.9999);
const west = clamp(bounds.getWest(), -179.9999, 179.9999);
const east = clamp(bounds.getEast(), -179.9999, 179.9999);

const a = latLonToIdx(south, west);
const b = latLonToIdx(north, east);

const latMin = Math.min(a.latIdx, b.latIdx);
const latMax = Math.max(a.latIdx, b.latIdx);
const lonMin = Math.min(a.lonIdx, b.lonIdx);
const lonMax = Math.max(a.lonIdx, b.lonIdx);

return { latMin, latMax, lonMin, lonMax };
}

async function loadVisibleCells(){
const bounds = map.getBounds();
const { latMin, latMax, lonMin, lonMax } = bboxToCellRange(bounds);

const tasks = [];
for (let la = latMin; la <= latMax; la++){
for (let lo = lonMin; lo <= lonMax; lo++){
const key = cellKey(la, lo);
if (state.loadedCells.has(key)) continue;
state.loadedCells.add(key);
tasks.push(loadCell(la, lo));
}
}

if (tasks.length) {
await Promise.allSettled(tasks);
countCells.textContent = String(state.loadedCells.size);
// categorie possono crescere man mano che carichi: aggiorniamo chips
rebuildCategoriesFromLoaded();
rebuildChips();
} else {
countCells.textContent = String(state.loadedCells.size);
}
}

async function loadCell(latIdx, lonIdx){
const url = cellUrl(latIdx, lonIdx);
try{
const res = await fetch(url, { cache:"no-store" });
if (!res.ok) return; // cella vuota/non esiste: ok
const geojson = await res.json();
const feats = (geojson.features || []).filter(f => f?.geometry?.type === "Point");
// append
for (const f of feats) {
// featureId stabile (se presente) altrimenti derivato da coordinate+name
const id = stableFeatureId(f);
f.__wj_id = id;
state.features.push(f);
}
countAll.textContent = String(state.features.length);
} catch(_e){
// silenzioso: non stressiamo
}
}

function stableFeatureId(feature){
const p = feature.properties || {};
if (p.id) return String(p.id);
const c = feature.geometry.coordinates;
const name = (p.name || "").trim();
return `${c[0].toFixed(6)}:${c[1].toFixed(6)}:${name}`; // good enough
}

// ---- Categories (non-judging highlight filter)
function rebuildCategoriesFromLoaded(){
const existing = new Set(state.categories.keys());
for (const f of state.features) {
const cat = (f.properties?.category || "").trim();
if (!cat) continue;
if (!existing.has(cat)){
state.categories.set(cat, false);
existing.add(cat);
}
}
}

function rebuildChips(){
chipsEl.innerHTML = "";
const cats = [...state.categories.keys()].sort((a,b)=>a.localeCompare(b, "it"));
for (const cat of cats){
const on = !!state.categories.get(cat);
const el = document.createElement("button");
el.className = "chip" + (on ? " is-on" : "");
el.textContent = cat;
el.addEventListener("click", () => {
state.categories.set(cat, !state.categories.get(cat));
rebuildChips();
applyFilterAndRender();
updateSuggestions();
});
chipsEl.appendChild(el);
}
}

function anyCategoryOn(){
for (const v of state.categories.values()) if (v) return true;
return false;
}

function isHighlighted(feature){
if (!anyCategoryOn()) return false;
const cat = feature.properties?.category || "";
return !!state.categories.get(cat);
}

// ---- Rendering
function markerStyle(feature, highlighted){
const baseOpacity = highlighted ? 1.0 : 0.55;
const radius = highlighted ? 7 : 6;
return L.circleMarker([feature.geometry.coordinates[1], feature.geometry.coordinates[0]], {
radius,
weight: highlighted ? 2 : 1,
color: highlighted ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.55)",
fillColor: highlighted ? "rgba(255,255,255,0.60)" : "rgba(255,255,255,0.26)",
fillOpacity: baseOpacity,
});
}

function popupContent(feature){
const p = feature.properties || {};
const name = escapeHtml(p.name || "Iniziativa");
const cat = escapeHtml(p.category || "‚Äî");
const city = escapeHtml(p.city || "");
const country = escapeHtml(p.country || "");
const level = p.level ?? 0;

const mode = getZoomMode(map.getZoom());

const lines = [];
lines.push(`<div class="pname">${name}</div>`);
lines.push(`<div class="pmuted">${cat}${city || country ? " ‚Ä¢ " : ""}${[city, country].filter(Boolean).join(", ")}</div>`);

if (mode !== "far"){
const short = escapeHtml(p.short || "");
if (short) lines.push(`<div class="ptext">${short}</div>`);
}

if (mode === "near"){
const descr = escapeHtml(p.description || "");
const website = p.website ? `<a href="${encodeURI(p.website)}" target="_blank" rel="noopener">Sito</a>` : "";
const verify = level === 2 ? "Verificato" : (level === 1 ? "In verifica" : "Segnalato");
if (descr) lines.push(`<div class="ptext">${descr}</div>`);
lines.push(`<div class="pmeta">Stato: <b>${verify}</b>${website ? " ‚Ä¢ " + website : ""}</div>`);
}

return `<div class="popup">${lines.join("")}</div>`;
}

function escapeHtml(str){
return String(str).replace(/[&<>"']/g, (m) => ({
"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
}[m]));
}

function applyZoomDisclosure(layer, feature){
const mode = getZoomMode(map.getZoom());
const hi = isHighlighted(feature);

if (mode === "far"){
layer.setStyle?.({
fillOpacity: hi ? 0.85 : 0.35,
opacity: hi ? 1.0 : 0.45,
weight: hi ? 2 : 1,
});
} else if (mode === "mid"){
layer.setStyle?.({
fillOpacity: hi ? 0.95 : 0.50,
opacity: hi ? 1.0 : 0.55,
weight: hi ? 2 : 1,
});
} else {
layer.setStyle?.({
fillOpacity: hi ? 1.0 : 0.60,
opacity: hi ? 1.0 : 0.65,
weight: hi ? 2 : 1,
});
}
}

function applyFilterAndRender(){
state.highlightedCount = 0;
cluster.clearLayers();
state.markersById.clear();

for (const f of state.features){
const hi = isHighlighted(f);
if (hi) state.highlightedCount++;

const shouldShow = state.onlyHighlighted ? hi : true;
if (!shouldShow) continue;

const m = markerStyle(f, hi);
m.bindPopup(popupContent(f), { closeButton:true, maxWidth:320 });
applyZoomDisclosure(m, f);
state.markersById.set(f.__wj_id, m);
cluster.addLayer(m);
}

countAll.textContent = String(state.features.length);
countHi.textContent = String(state.highlightedCount);
countCells.textContent = String(state.loadedCells.size);
}

// ---- Suggestions (non invasiva)
function haversineKm(a, b){
const R = 6371;
const dLat = (b.lat - a.lat) * Math.PI/180;
const dLon = (b.lng - a.lng) * Math.PI/180;
const lat1 = a.lat * Math.PI/180;
const lat2 = b.lat * Math.PI/180;
const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
return 2 * R * Math.asin(Math.sqrt(s));
}

function updateSuggestions(){
// ‚ÄúVicino a te‚Äù = user position se disponibile, altrimenti centro mappa
const ref = state.userLatLng || map.getCenter();

// non stressare: se non abbiamo abbastanza punti, nascondi
if (!state.features.length){
suggestEl.classList.add("is-hidden");
return;
}

// scan limit (sicurezza)
const feats = state.features.length > MAX_POINTS_FOR_SUGGESTIONS_SCAN
? state.features.slice(state.features.length - MAX_POINTS_FOR_SUGGESTIONS_SCAN)
: state.features;

// troviamo 3 pi√π vicini TRA I PUNTI CARICATI (coerente col ‚Äúnon anticipa‚Äù)
const scored = [];
for (const f of feats){
const c = f.geometry.coordinates;
const ll = L.latLng(c[1], c[0]);
const d = haversineKm(ref, ll);
scored.push({ f, d });
}
scored.sort((x,y)=>x.d - y.d);
const top = scored.slice(0, 3);

if (!top.length){
suggestEl.classList.add("is-hidden");
return;
}

// title/subtitle (no CTA, tono umano)
suggestTitle.textContent = state.userLatLng ? "Vicino a te" : "Qui intorno";
suggestSubtitle.textContent = "3 azioni di cura (tra i punti caricati)";

suggestItems.innerHTML = "";
for (const item of top){
const p = item.f.properties || {};
const name = escapeHtml(p.name || "Iniziativa");
const cat = escapeHtml(p.category || "‚Äî");
const km = item.d < 1 ? `${Math.round(item.d*1000)} m` : `${item.d.toFixed(1)} km`;

const row = document.createElement("div");
row.className = "sitem";
row.innerHTML = `${name} <span class="meta">‚Ä¢ ${cat} ‚Ä¢ ${km}</span>`;
// click = apri popup (non √® CTA, √® solo ‚Äúcuriosit√†‚Äù)
row.style.cursor = "pointer";
row.addEventListener("click", () => {
const id = item.f.__wj_id;
const layer = state.markersById.get(id);
if (layer){
map.flyTo(layer.getLatLng(), Math.max(map.getZoom(), 10), { duration: 0.6 });
setTimeout(() => layer.openPopup(), 350);
}
});
suggestItems.appendChild(row);
}

suggestEl.classList.remove("is-hidden");
}

// Init
(async function init(){
setModeHint();

// prima load iniziale (celle visibili)
await loadVisibleCells();
applyFilterAndRender();
updateSuggestions();
})();
</script>

<!--
‚úÖ COME PREPARARE I FILE CELLA (una volta sola)

1) Parti dal tuo GeoJSON master (FeatureCollection) con TUTTI i punti.
2) Splittalo in celle da GRID_DEG gradi.
3) Salva ogni cella in /data/cells/c_{latIdx}_{lonIdx}.geojson

Dove:
latIdx = floor((lat + 90) / GRID_DEG)
lonIdx = floor((lon + 180) / GRID_DEG)

Se vuoi, posso anche darti uno script Python pronto (offline) che prende
points.geojson e genera automaticamente la cartella /data/cells/.
-->
</body>
</html>
