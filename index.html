<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wejuman — A living map of human action</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
html, body, #map { height: 100%; margin: 0; }
:root{
--bar: rgba(255,255,255,.92);
--text:#111;
--muted:#5a5a5a;
--shadow: 0 10px 30px rgba(0,0,0,.18);
--radius: 16px;
}

.bar{
position: fixed;
left: 50%;
transform: translateX(-50%);
width: min(720px, calc(100% - 24px));
background: var(--bar);
color: var(--text);
border-radius: var(--radius);
box-shadow: var(--shadow);
z-index: 1000;
font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
}

#topBar{
top: 12px;
padding: 12px 14px;
display: grid;
grid-template-columns: 44px 1fr auto;
gap: 10px;
align-items: center;
}
#btnMenu{
width:44px;height:44px;border-radius:12px;border:none;
background: rgba(0,0,0,.06);
font-size: 20px; cursor:pointer;
}
#title{ font-weight: 800; letter-spacing:.2px; }
#subtitle{ font-size: 12px; color: var(--muted); margin-top:2px; }

#chip{
padding: 10px 12px;
border-radius: 999px;
background: rgba(0,0,0,.06);
font-size: 13px;
color: var(--muted);
white-space: nowrap;
}

#bottomBar{
bottom: 12px;
padding: 12px 14px;
max-height: 32vh;
overflow: auto;
}
#nearTitle{ font-weight: 800; margin-bottom: 6px; }
.nearItem{
font-size: 14px;
color: var(--text);
padding: 6px 0;
border-top: 1px solid rgba(0,0,0,.06);
cursor: pointer;
}
.nearItem:first-of-type{ border-top:none; }
.nearMeta{ color: var(--muted); font-size: 13px; }

/* Modal menu */
#overlay{
position: fixed; inset: 0;
background: rgba(0,0,0,.22);
display:none;
z-index: 2000;
}
#panel{
width: min(760px, calc(100% - 24px));
margin: 90px auto;
background: rgba(255,255,255,.94);
border-radius: 18px;
box-shadow: var(--shadow);
padding: 16px;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
color: var(--text);
}
#panel h3{ margin:0 0 6px 0; }
#panel p{ margin:0 0 10px 0; color: var(--muted); }

.catWrap{ display:flex; flex-wrap: wrap; gap: 10px; margin-top: 8px; }
.cat{
padding: 10px 14px;
border-radius: 999px;
background: rgba(0,0,0,.06);
cursor: pointer;
user-select:none;
font-weight: 700;
font-size: 14px;
}
.cat.active{ background:#2ecbd6; color:#fff; }

.row{
display:flex; gap: 10px; align-items:center; margin-top: 12px;
padding-top: 10px; border-top: 1px solid rgba(0,0,0,.08);
color: var(--muted);
font-size: 14px;
}
input[type="checkbox"]{ width:18px; height:18px; }

.closeBtn{
margin-top: 12px;
border:none;
background: rgba(0,0,0,.06);
padding: 10px 14px;
border-radius: 12px;
cursor:pointer;
font-weight: 700;
}
</style>
</head>

<body>
<div id="map"></div>

<div id="topBar" class="bar">
<button id="btnMenu" title="Categorie">☰</button>

<div>
<div id="title">Wejuman</div>
<div id="subtitle">A living map human action</div>
<div id="placeLabel"></div>
</div>

<div id="chip">Dati: points.json</div>
</div>

<div id="bottomBar" class="bar">
<div id="nearTitle">Nearby</div>
<div id="nearList">
<div class="nearMeta">Move or zoom the map to discover nearby initiatives.</div>
</div>
</div>

<div id="overlay">
<div id="panel">
<h3>Categorie</h3>
<p><b>Il filtro non giudica</b>: evidenzia ciò che cerchi, senza “cancellare” il resto.</p>
<div class="catWrap" id="cats"></div>

<div class="row">
<input id="onlyHighlighted" type="checkbox">
<label for="onlyHighlighted">Mostra solo evidenziati</label>
</div>

<div class="row" id="stats">—</div>

<button class="closeBtn" id="btnClose">Chiudi</button>
</div>
</div>

<script>
// ===== CONFIG =====
const POINTS_URL = "points.json";
const CATEGORIES = [
"Ambiente","Cibo","Acqua","Salute","Educazione",
"Bambini","Donne","Diritti umani","Emergenze",
"Comunità","Rifugiati","Generale"
];

// ===== STATE =====
let points = [];
let selected = "Tutte"; // categoria evidenziata
let onlyHighlighted = false; // nasconde gli altri se true

let markers = []; // {p, m}
let placeCache = new Map(); // key= "lat,lon" approx -> text
let reverseTimer = null;
let lastReverseAtZoomBand = ""; // evita spam
let abortCtl = null;

// ===== MAP =====
const map = L.map("map", { zoomControl: false }).setView([20,0], 2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19
}).addTo(map);

// ===== UI =====
const elSub = document.getElementById("placeLabel");
const elNear = document.getElementById("nearList");
const elStats = document.getElementById("stats");

document.getElementById("btnMenu").onclick = openMenu;
document.getElementById("btnClose").onclick = closeMenu;
document.getElementById("overlay").onclick = (e)=>{ if(e.target.id==="overlay") closeMenu(); };

const chkOnly = document.getElementById("onlyHighlighted");
chkOnly.onchange = ()=>{
onlyHighlighted = chkOnly.checked;
applyHighlight();
updateNearby();
updateStats();
};

// ===== LOAD =====
fetch(POINTS_URL)
.then(r=>r.json())
.then(d=>{
points = (Array.isArray(d)? d : []).map(p => ({
...p,
category: (p.category && p.category.trim()) ? p.category.trim() : "Generale"
}));
buildMarkers();
buildMenu();
applyHighlight();
updateNearby();
updateStats();
updatePerception(); // set subtitle initial
})
.catch(()=>{
elNear.innerHTML = `<div class="nearMeta">Errore: non riesco a caricare points.json</div>`;
});

function buildMarkers(){
markers.forEach(x=> map.removeLayer(x.m));
markers = [];

points.forEach(p=>{
const m = L.marker([p.lat, p.lon]).addTo(map);
m.on("click", ()=>{
const url = p.website ? p.website : `https://www.google.com/search?q=${encodeURIComponent(p.name)}`;
window.open(url, "_blank");
});
markers.push({p, m});
});
}

// ===== PRO: 3 states (Lontano / Medio / Vicino) =====
function zoomBand(z){
if(z < 4) return "lontano";
if(z < 10) return "medio";
return "vicino";
}

function updatePerception(){
// subtitle fisso: non sovrascrivere mai l’HTML
return;
}


// ===== HIGHLIGHT (non giudica) =====
function isHighlighted(p){
return (selected==="Tutte") ? true : (p.category === selected);
}

function applyHighlight(){
let visibleCount = 0;
let highlightedCount = 0;

markers.forEach(({p,m})=>{
const hi = isHighlighted(p);
if(hi) highlightedCount++;

if(onlyHighlighted && !hi){
if(map.hasLayer(m)) map.removeLayer(m);
}else{
if(!map.hasLayer(m)) m.addTo(map);
const iconEl = m.getElement && m.getElement();
if(iconEl){
iconEl.style.opacity = hi ? "1" : "0.28";
iconEl.style.filter = hi ? "none" : "grayscale(1)";
}
visibleCount++;
}
});

updateStats(visibleCount, highlightedCount);
}

function updateStats(visibleCount, highlightedCount){
if(visibleCount == null){
// ricalcolo veloce
visibleCount = markers.filter(({p,m})=> map.hasLayer(m)).length;
highlightedCount = points.filter(isHighlighted).length;
}
elStats.textContent = `Punti: ${points.length} · Visibili: ${visibleCount} · Evidenziati: ${highlightedCount}`;
}

/*******************************
* NEARBY PRO (Local + OSM)
* Only SOCIAL actions, only menu categories
*******************************/

// 1) MENU CANONICO (solo queste categorie)
const CATEGORIES = [
"Food for the poor",
"Homeless support",
"Refugees",
"Children & orphans",
"Disability support",
"Domestic violence support",
"Mental health support",
"Community center",
"Volunteering"
];
const ALLOWED_CATS = new Set(CATEGORIES);

// 2) Helpers: active categories (dalle chips)
// - Se hai state.categories (Map cat->bool) lo usa.
// - Se non hai selezioni attive, usa tutte.
function getActiveCategories(){
if (typeof state !== "undefined" && state.categories instanceof Map){
const on = [];
for (const [k,v] of state.categories.entries()){
if (v) on.push(k);
}
return on.length ? on : CATEGORIES.slice();
}
return CATEGORIES.slice();
}

// 3) OSM -> categorie Wejuman (SOCIAL ONLY)
function mapOsmToCategory(tags){
// Social facilities
if (tags.amenity === "social_facility"){
const sf = tags.social_facility || tags["social_facility:for"];
if (sf === "food_bank" || sf === "soup_kitchen") return "Food for the poor";
if (sf === "shelter") return "Homeless support";
if (sf === "refugee_site") return "Refugees";
if (sf === "day_care" || sf === "group_home") return "Children & orphans";
if (sf === "assisted_living" || sf === "workshop") return "Disability support";
}

// Community centers
if (tags.amenity === "community_centre") return "Community center";

// NGOs/Charities offices -> bucket "Volunteering"
if (tags.office === "ngo" || tags.office === "charity") return "Volunteering";

// Explicit volunteering tags -> "Volunteering"
if (tags.volunteer === "yes" || tags.volunteering === "yes") return "Volunteering";

return null;
}

// 4) Overpass fetch (cache + abort)
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";
const overpassCache = new Map(); // key -> {ts, items}
let overpassAbort = null;

function makeOverpassKey(lat, lon, radiusM, activeCats){
// bucket to reduce calls
const latB = lat.toFixed(3);
const lonB = lon.toFixed(3);
const catsKey = activeCats.slice().sort().join("|");
return `${latB}|${lonB}|${radiusM}|${catsKey}`;
}

async function fetchOverpassSocial(lat, lon, radiusM, activeCats){
const key = makeOverpassKey(lat, lon, radiusM, activeCats);
const cached = overpassCache.get(key);
if (cached && (Date.now() - cached.ts) < 1000 * 60 * 10) return cached.items; // 10 min

if (overpassAbort) overpassAbort.abort();
overpassAbort = new AbortController();

const query = `
[out:json][timeout:20];
(
node(around:${radiusM},${lat},${lon})["amenity"="social_facility"];
way(around:${radiusM},${lat},${lon})["amenity"="social_facility"];
relation(around:${radiusM},${lat},${lon})["amenity"="social_facility"];

node(around:${radiusM},${lat},${lon})["amenity"="community_centre"];
way(around:${radiusM},${lat},${lon})["amenity"="community_centre"];
relation(around:${radiusM},${lat},${lon})["amenity"="community_centre"];

node(around:${radiusM},${lat},${lon})["office"="ngo"];
way(around:${radiusM},${lat},${lon})["office"="ngo"];
relation(around:${radiusM},${lat},${lon})["office"="ngo"];

node(around:${radiusM},${lat},${lon})["office"="charity"];
way(around:${radiusM},${lat},${lon})["office"="charity"];
relation(around:${radiusM},${lat},${lon})["office"="charity"];

node(around:${radiusM},${lat},${lon})["volunteer"="yes"];
node(around:${radiusM},${lat},${lon})["volunteering"="yes"];
);
out center tags;
`.trim();

const res = await fetch(OVERPASS_URL, {
method: "POST",
body: query,
signal: overpassAbort.signal
});
if (!res.ok) return [];

const json = await res.json();
const els = json.elements || [];

const activeSet = new Set(activeCats);

const items = els.map(el => {
const tags = el.tags || {};
const cat = mapOsmToCategory(tags);
if (!cat) return null;
if (!ALLOWED_CATS.has(cat)) return null;
if (!activeSet.has(cat)) return null;

const name =
tags.name ||
tags["operator"] ||
tags["brand"] ||
"Community action";

const lat2 = (el.type === "node") ? el.lat : (el.center ? el.center.lat : null);
const lon2 = (el.type === "node") ? el.lon : (el.center ? el.center.lon : null);
if (lat2 == null || lon2 == null) return null;

return {
source: "osm",
name,
category: cat,
lat: lat2,
lon: lon2,
website: tags.website || tags.url || ""
};
}).filter(Boolean);

overpassCache.set(key, { ts: Date.now(), items });
return items;
}

// 5) Click external explore (fallback)
function openExplore(name, category){
const q = encodeURIComponent(`${name} ${category}`);
window.open(`https://www.google.com/search?q=${q}`, "_blank");
}

// 6) Utility: format distance
function formatDistance(km){
if (km < 1) return `${Math.round(km * 1000)} m`;
return `${km.toFixed(1)} km`;
}

// 7) MAIN: updateNearby (Local first, then OSM fill)
let nearbyDebounce = null;

async function updateNearbyPRO(){
const center = map.getCenter();
const MAX_ITEMS = 20;

const activeCats = getActiveCategories();
const activeSet = new Set(activeCats);

// 7.1) local points (your dataset)
// NOTE: serve p.category nel tuo points.json per essere perfetto.
const local = (Array.isArray(points) ? points : [])
.map(p => ({
source: "local",
name: p.name || "Action",
category: (p.category || "Volunteering"),
lat: p.lat,
lon: p.lon,
website: p.website || "",
tagline: p.tagline || ""
}))
.filter(x => ALLOWED_CATS.has(x.category))
.filter(x => activeSet.has(x.category))
.map(x => ({
...x,
km: map.distance(center, [x.lat, x.lon]) / 1000
}))
.sort((a,b) => a.km - b.km);

// Dedup + choose
const chosen = [];
const dedupe = new Set();

function pushUnique(x){
const key = `${x.name}|${x.lat.toFixed(5)}|${x.lon.toFixed(5)}`;
if (dedupe.has(key)) return;
dedupe.add(key);
chosen.push(x);
}

for (const x of local){
pushUnique(x);
if (chosen.length >= MAX_ITEMS) break;
}

// 7.2) If not enough, fill with OSM around center
// radius steps (meters): social suggestions near the map center
const radiusStepsM = [2000, 5000, 12000, 25000, 50000]; // 2km→5→12→25→50

if (chosen.length < MAX_ITEMS){
for (const r of radiusStepsM){
const osm = await fetchOverpassSocial(center.lat, center.lng, r, activeCats);
const scored = osm
.map(x => ({ ...x, km: map.distance(center, [x.lat, x.lon]) / 1000 }))
.sort((a,b) => a.km - b.km);

for (const x of scored){
pushUnique(x);
if (chosen.length >= MAX_ITEMS) break;
}
if (chosen.length >= MAX_ITEMS) break;
}
}

// 7.3) Render
if (!chosen.length){
elNear.innerHTML = `<div class="nearMeta">No nearby activities for the selected categories. Move the map or zoom out.</div>`;
return;
}

elNear.innerHTML = chosen.slice(0, MAX_ITEMS).map(x => {
const title = escapeHtml(x.name);
const cat = escapeHtml(x.category);
const dist = formatDistance(x.km);

const tagline = x.tagline
? `<div class="nearMeta">${escapeHtml(x.tagline)}</div>`
: "";

// click:
const click = x.website
? `window.open('${encodeURI(x.website)}','_blank')`
: `openExplore(${JSON.stringify(x.name)}, ${JSON.stringify(x.category)})`;

return `
<div class="nearItem" style="cursor:pointer" onclick="${click}">
<div class="nearName">${title}</div>
<div class="nearMeta">${cat} · ${dist}</div>
${tagline}
</div>
`;
}).join("");
}

// 8) Schedule / debounce (call on move/zoom)
function scheduleNearbyPRO(){
clearTimeout(nearbyDebounce);
nearbyDebounce = setTimeout(() => {
updateNearbyPRO();
}, 300);
}

// IMPORTANT: hook into map events (keep only one listener if you already have it)
map.on("moveend zoomend", scheduleNearbyPRO);

// Initial run
scheduleNearbyPRO();

window.openLink = function(name, website){
const url = website ? website : `https://www.google.com/search?q=${encodeURIComponent(name)}`;
window.open(url, "_blank");
};

function escapeHtml(s){
return (s||"").replace(/[&<>"']/g, m=>({
"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
}[m]));
}

// ===== REVERSE GEOCODE (stabile, no network crash) =====
function shouldReverseNow(){
const band = zoomBand(map.getZoom());
// Niente reverse in "lontano"
if(band === "lontano") return false;
return true;
}

function reverseGeocode(){
if(!shouldReverseNow()) return;

const c = map.getCenter();
// chiave cache arrotondata
const key = `${c.lat.toFixed(3)},${c.lng.toFixed(3)}`;
if(placeCache.has(key)){
// elSub.textContent = placeCache.get(key);
return;
}

// evita sovrapposizioni
if(abortCtl) abortCtl.abort();
abortCtl = new AbortController();

fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${c.lat}&lon=${c.lng}`, {
signal: abortCtl.signal,
headers: { "Accept": "application/json" }
})
.then(r=>r.json())
.then(d=>{
const a = d && d.address ? d.address : {};
const place = a.city || a.town || a.village || a.county || a.state || a.country || "—";
placeCache.set(key, place);
elSub.textContent = place; // qui appare “Roma”
})
.catch(()=>{
// fallback: NON rompe nulla
// non cambiamo testo se fallisce
});
}

// ===== MENU =====
function buildMenu(){
const cats = document.getElementById("cats");
cats.innerHTML = "";

const all = ["Tutte", ...CATEGORIES];
all.forEach(cat=>{
const b = document.createElement("div");
b.className = "cat" + (cat===selected ? " active" : "");
b.textContent = cat;
b.onclick = ()=>{
selected = cat;
// aggiorna stato pulsanti
Array.from(cats.children).forEach(x=> x.classList.remove("active"));
b.classList.add("active");

applyHighlight();
updateNearby();
updateStats();
};
cats.appendChild(b);
});
}

function openMenu(){
document.getElementById("overlay").style.display = "block";
chkOnly.checked = onlyHighlighted;
updateStats();
}
function closeMenu(){
document.getElementById("overlay").style.display = "none";
}

// ===== EVENTS =====
map.on("zoomend", ()=>{
updatePerception();
updateNearby();
applyHighlight();

// reverse solo se “medio/vicino” e con debounce
clearTimeout(reverseTimer);
reverseTimer = setTimeout(reverseGeocode, 550);
});

map.on("moveend", ()=>{
updateNearby();

// reverse SOLO quando cambia banda o quando ti fermi
clearTimeout(reverseTimer);
reverseTimer = setTimeout(reverseGeocode, 650);
});

</script>
</body>
</html>
